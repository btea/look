<style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>源码 parse 成 AST 之后，需要进行 AST 的遍历和增删改（transform）。那么 transform 的流程是什么样的？</p>
<p>babel 会递归遍历 AST，遍历过程中处理到不同的 AST 会调用不同的 visitor 函数来实现 transform。这是 visitor 模式的应用。</p>
<h2 data-id="heading-0">visitor模式</h2>
<p>visitor 模式（访问者模式）是 23 种经典设计模式中的一种。当被操作的对象结构比较稳定，而操作对象的逻辑经常变化的时候，通过分离逻辑和对象结构，使得他们能独立扩展。这就是 visitor 模式的思想。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a89899432b549d198a98f404e791a97~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
<p>如图，Element 和 Visitor 分别代表对象结构和操作逻辑，两者可以独立扩展，在 Client 里面来组合两者，使用 visitor 操作 element。这就是 visitor 模式。</p>
<p>对应到 babel traverse 的实现，就是 AST 和 visitor 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c592dedef6ff429ebbcb350e0afa404d~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
<p>这样使得 AST 的结构和遍历算法固定，visitor 可以通过插件独立扩展。</p>
<h2 data-id="heading-1">路径和作用域</h2>
<p>babel AST 中只包含源码的一些信息，但是操作 AST 时要拿到父节点的信息，并且也需要对 AST 增删改的方法，这些都在 path 对象里。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293327a616cc4c90b7fa40c7e28761a0~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
<p>babel 会在 traverse 的过程中在 path 里维护节点的父节点引用，在其中保存 scope（作用域）的信息，同时也会提供增删改 AST 的方法。</p>
<h3 data-id="heading-2">path 的属性</h3>
<p>path 大概有这些属性和方法</p>
<pre><code class="hljs language-javascript" lang="javascript">path {
    <span class="hljs-comment">// 属性：</span>
    node 
    parent
    parentPath
    scope
    hub
    container
    key
    listKey
    
    <span class="hljs-comment">// 方法</span>
    get(key) 
    set(key, node)
    inList()
    getSibling(key) 
    getNextSibling()
    getPrevSibling()
    getAllPrevSiblings()
    getAllNextSiblings()
    isXxx(opts)
    assertXxx(opts)
    find(callback)
    findParent(callback)
    
    insertBefore(nodes)
    insertAfter(nodes)
    replaceWith(replacement)
    replaceWithMultiple(nodes)
    replaceWithSourceString(replacement)
    remove()
    
    traverse(visitor, state)
    skip()
    stop()
}
</code></pre>
<p>它们各自的含义：</p>
<ul>
<li>path.node 当前 AST 节点</li>
<li>path.parent 父 AST 节点</li>
<li>path.parentPath 父 AST 节点的 path</li>
<li>path.scope 作用域，见下文详解</li>
<li>path.hub 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串</li>
<li>path.container 当前 AST 节点所在的父节点属性的属性值</li>
<li>path.key 当前 AST 节点所在父节点属性的属性名或所在数组的下标</li>
<li>path.listkey 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined</li>
</ul>
<h4 data-id="heading-3">container、listkey、key（不常用，可略过）</h4>
<p>container、listkey、key 这三个属性有点绕（也不太常用，可以跳过，后面实现手写 babel  的时候才会用到），解释一下：</p>
<p>因为 AST 节点要挂在父 AST 节点的某个属性上，那个属性的属性值就是这个 AST 节点的 container。</p>
<p>比如 CallExpression 有 callee 和 arguments 属性，那么对于 callee 的 AST 节点来说，callee 的属性值就是它的 container，而 callee 就是它的 key。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce55f6c749d4e35ad6460de6f5be71a~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>而 BlockStatement 有 body 属性，是一个数组，对于数组中的每一个 AST 来说，这个数组就是它们的 container，而 listKey 是 body，key 则是下标。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b48a0cdddb4344d1b9343e04818460ad~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<h3 data-id="heading-4">path 的方法</h3>
<p>path 有如下方法</p>
<ul>
<li>inList() 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true</li>
<li>get(key) 获取某个属性的 path</li>
<li>set(key, node) 设置某个属性的值</li>
<li>getSibling(key) 获取某个下标的兄弟节点</li>
<li>getNextSibling() 获取下一个兄弟节点</li>
<li>getPrevSibling() 获取上一个兄弟节点</li>
<li>getAllPrevSiblings() 获取之前的所有兄弟节点</li>
<li>getAllNextSiblings() 获取之后的所有兄弟节点</li>
<li>find(callback) 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找</li>
<li>findParent(callback) 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找</li>
<li>isXxx(opts) 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: 'a'})</li>
<li>assertXxx(opts) 同 isXxx，但是不返回布尔值，而是抛出异常</li>
<li>insertBefore(nodes) 在之前插入节点，可以是单个节点或者节点数组</li>
<li>insertAfter(nodes) 在之后插入节点，可以是单个节点或者节点数组</li>
<li>replaceWith(replacement) 用某个节点替换当前节点</li>
<li>replaceWithMultiple(nodes) 用多个节点替换当前节点</li>
<li>replaceWithSourceString(replacement) 解析源码成 AST，然后替换当前节点</li>
<li>remove() 删除当前节点</li>
<li>traverse(visitor, state) 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）</li>
<li>skip() 跳过当前节点的子节点的遍历</li>
<li>stop() 结束所有遍历</li>
</ul>
<h3 data-id="heading-5">作用域 path.scope</h3>
<p>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。</p>
<p>属性和方法大概有这些</p>
<pre><code class="">path.scope {
    bindings
    block
    parent
    parentBlock
    path
    references
 
    dump()
    parentBlock()
    getAllBindings()
    getBinding(name)
    hasBinding(name)
    getOwnBinding(name)
    parentHasBinding(name)
    removeBinding(name)
    moveBindingTo(name, scope)
    generateUid(name)
}
</code></pre>
<p>各自的含义：</p>
<ul>
<li>scope.bindings 当前作用域内声明的所有变量</li>
<li>scope.block 生成作用域的 block，详见下文</li>
<li>scope.path 生成作用域的节点对应的 path</li>
<li>scope.references 所有 binding 的引用对应的 path，详见下文</li>
<li>scope.dump() 打印作用域链的所有 binding 到控制台</li>
<li>scope.parentBlock() 父级作用域的 block</li>
<li>getAllBindings() 从当前作用域到根作用域的所有 binding 的合并</li>
<li>getBinding(name) 查找某个 binding，从当前作用域一直查找到根作用域</li>
<li>getOwnBinding(name) 从当前作用域查找 binding</li>
<li>parentHasBinding(name, noGlobals) 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false</li>
<li>removeBinding(name)  删除某个 binding</li>
<li>hasBinding(name, noGlobals) 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false</li>
<li>moveBindingTo(name, scope) 把当前作用域中的某个 binding 移动到其他作用域</li>
<li>generateUid(name) 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字。</li>
</ul>
<h4 data-id="heading-6">scope.block</h4>
<p>能形成 scope 的有这些节点，这些节点也叫 block 节点。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> type Scopable =
  | BlockStatement
  | CatchClause
  | DoWhileStatement
  | ForInStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | Program
  | ObjectMethod
  | SwitchStatement
  | WhileStatement
  | ArrowFunctionExpression
  | ClassExpression
  | ClassDeclaration
  | ForOfStatement
  | ClassMethod
  | ClassPrivateMethod
  | StaticBlock
  | TSModuleBlock;
</code></pre>
<p>我们可以通过 path.scope.block 来拿到所在的块对应的节点，通过 path.scope.parentBlock 拿到父作用域对应的块节点。</p>
<p>一般情况下我们不需要拿到生成作用域的块节点，只需要通过 path.scope 拿到作用域的信息，通过 path.scope.parent 拿到父作用域的信息。</p>
<h4 data-id="heading-7">scope.bindings、scope.references（重点）</h4>
<p>作用域中保存的是声明的变量和对应的值，每一个声明叫做一个binding（绑定）。</p>
<p>比如这样一段代码</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
</code></pre>
<p>它的 path.scope.bindings 是这样的</p>
<pre><code class="hljs language-javascript" lang="javascript">bindings: {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">constant</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">constantViolations</span>: [],
        <span class="hljs-attr">identifier</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">'Identifier'</span>, ...}
        <span class="hljs-attr">kind</span>:<span class="hljs-string">'const'</span>,
        <span class="hljs-attr">path</span>: {node,...}
        <span class="hljs-attr">referenced</span>: <span class="hljs-literal">false</span>
        <span class="hljs-attr">referencePaths</span>: [],
        <span class="hljs-attr">references</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">scope</span>: ...
    }
}
</code></pre>
<p>因为我们在当前 scope 中声明了 a 这个变量，所以 bindings 中有 a 的 binding，每一个 binding 都有 kind，这代表绑定的类型：</p>
<ul>
<li>var、let、const 分别代表 var、let、const 形式声明的变量</li>
<li>param 代表参数的声明</li>
<li>module 代表 import 的变量的声明</li>
</ul>
<p>binding 有多种 kind，代表不同的声明方式。</p>
<p>binding.identifier 和 binding.path，分别代表标识符的 AST、整个声明语句的 AST。</p>
<p>声明之后的变量会被引用和修改，binding.referenced 代表声明的变量是否被引用，binding.constant 代表变量是否被修改过。如果被引用了，就可以通过 binding.referencePaths 拿到所有引用的语句的 path。如果被修改了，可以通过 binding.constViolations 拿到所有修改的语句的 path。</p>
<p>path 的 api 还是比较多的，这也是 babel 最强大的地方。主要是操作当前节点、当前节点的父节点、兄弟节点，作用域，以及增删改的方法。</p>
<h3 data-id="heading-8">node 链、block 链、scope 链</h3>
<p>从某一个节点出发有 3 条链，path 和 path.parent 串联起来的 AST node 链，path.scope 和 path.scope.parent 串联起来的作用域 scope 链，path.scope.block 和 path.scope.parentBlock 串联起来的块 AST block 链。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0c2bddf922742fe98d0928e98d020df~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>注意，这三条链只是从某个节点出发到父节点的路径，整个 AST 中的路径不止一条，整体来看就是 ast 树、scope 树、block 树，不过我们写插件一般只用到某一条路径。</p>
<h2 data-id="heading-9">state</h2>
<p>state 是遍历过程中 AST 节点之间传递数据的方式，插件的 visitor 中，第一个参数是 path，第二个参数就是 state。插件可以从 state 中拿到 opts，也就是插件的配置项，也可以拿到 file 对象，file 中有一些文件级别的信息，这个也可以从 path.hub.file 中拿。</p>
<pre><code class="">state {
    file
    opts
}
</code></pre>
<p>可以在遍历的过程中在 state 中存一些状态信息，用于后续的 AST 处理。不是遍历过程中的数据，可以通过 file.set、file.get 来保存。</p>
<h2 data-id="heading-10">AST 的别名</h2>
<p>遍历的时候要指定 visitor 处理的 AST，有的时候需要对多个节点做同样的处理，babel 支持指定多个 AST 类型，也可以通过别名指定一系列类型。</p>
<pre><code class="hljs language-javascript" lang="javascript">  <span class="hljs-comment">// 单个 AST 类型</span>
  <span class="hljs-function"><span class="hljs-title">FunctionDeclaration</span>(<span class="hljs-params">path, state</span>)</span> {},
  <span class="hljs-comment">// 多个 AST 类型</span>
  <span class="hljs-string">'FunctionDeclaration|VariableDeclaration'</span>(path, state) {}
  <span class="hljs-comment">// AST 类型别名</span>
  <span class="hljs-function"><span class="hljs-title">Declaration</span>(<span class="hljs-params"></span>)</span>{}
</code></pre>
<p>可以在<a href="https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-types" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-types" ref="nofollow noopener noreferrer">文档中</a>查到某个 AST 类型的别名是啥，某个别名都包含哪些 AST 类型可以在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-types%2Fsrc%2Fast-types%2Fgenerated%2Findex.ts%23L2489-L2535" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2489-L2535" ref="nofollow noopener noreferrer">babel-types的类型定义</a>处查。</p>
<p>建议把 @babel/types 源码下载下来看，类型定义在 src/ast-types/generated 目录下，这样可以利用 ide 的功能方便的查看每种 alias 的具体 AST 类型。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ce124c18bd4e5c95760212e5e16078~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>所有的 AST 相关的信息都可以在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-types%2Fsrc%2Fdefinitions%2Fcore.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-types/src/definitions/core.ts" ref="nofollow noopener noreferrer">babel-types</a>里查看，每一个 AST 节点怎么创建、怎么校验、怎么遍历，其实都与 AST 的结构有关系，这些都在 babel-types 里面定义。</p>
<p>比如if就定义了有哪些属性可以遍历、别名是什么，每一个属性怎么校验，然后会根据这些规则生成xxx，isXxx，assertXxx等api用于创建、判断AST节点。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/004cb659aeaa4c749cfff6b2187383a4~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
<h2 data-id="heading-11">总结</h2>
<p>这一节我们学习了 visitor 模式，通过对象和操作分离的方式使得 visitor 可以独立扩展，然后学习了babel 强大的 path，包括它的属性和操作 AST 的 api，以及作用域 scope 的一些概念和 api。学习了 3 条链，AST 链、作用域链、block 链。之后了解了 AST 的别名，可以通过 babel-types 的类型定义来查看所有的 AST 的别名等信息。</p>
<p>学完这一节，我们掌握了强大的 path api，对 babel 插件的掌握就算完成了一大半了。</p>
<p>api 比较多，马上消化不太现实，不用着急，后面实战会大量用到。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>