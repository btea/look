<style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一节我们学习了 babel 插件的分类、babel 的 preset、helper、runtime。babel 的功能基本都建立在这些之上，babel 6 到 babel 7 还有未来的 babel 8 基于这些做了不同的设计。</p>
<h2 data-id="heading-0">从目标语言版本到目标浏览器</h2>
<p>我们通过插件完成了各种代码（es next、proposal、typescript/flow/jsx...）到 es5 的转换，然后把不同的转换插件封装到不同的 preset （preset-env、preset-typescript、preset-react...）里，而且还把插件内部的公共逻辑抽成 helper 来复用，并且提供了 runtime 包用于注入运行时的 api。这样已经能够达到不同语法的代码转 es5 同时对 api 进行 polyfill 的目标了。 但是这样就够了么？还有哪些问题？</p>
<ul>
<li>
<p>我们现在是指定了目标环境支持 es5，那么如果目标环境支持了部分 es6（es2015）、es7（es2016）等，那岂不是做了很多无用功？</p>
</li>
<li>
<p>preset-es2015、preset-es2016、preset-stage-x 这种 preset 跟随版本走的，那岂不是经常变，得经常改这些 preset 的内容 （当某个提案从 stage 0 进入到 stage 1 就得改下），这样多累啊，而且用户也得经常改配置，stage-x 对他来说是个黑盒，不靠谱。</p>
</li>
</ul>
<p><strong>怎么解决这些问题呢？</strong></p>
<p>babel6 到 babel7 的变化给出了答案：</p>
<p>preset 经常变的问题通过废弃 stage-x 和 es20xx 的 preset，改成 preset-env 和 plugin-proposal-xx 的方式来解决， 这样不需要指定用的是 es 几了，默认会全部支持，包含<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmaster%2Fpackages%2Fbabel-compat-data%2Fscripts%2Fdata%2Fplugin-features.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js" ref="nofollow noopener noreferrer">所有的已经是语言标准特性的 transform plugin</a>， 而且 stage-x 有哪些不再是黑盒，用户想用啥还在 proposal 的特性直接显示引入对应的 plugin。</p>
<p>多转换了目标环境支持的语法或 api 的问题是要解决转换的精准度的问题，可是目标环境那么多，浏览器版本、node 版本、electron 版本每年都在变，怎么做到精准？</p>
<h5 data-id="heading-1">comat-table</h5>
<p>答案是 compat-table 的数据，compat-table 提供了每个特性在不同环境中的支持版本。</p>
<p>比如<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkangax%2Fcompat-table%2Fblob%2Fgh-pages%2Fdata-es6.js%23L1864-L1904" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/kangax/compat-table/blob/gh-pages/data-es6.js#L1864-L1904" ref="nofollow noopener noreferrer">默认参数</a>这个 es2015 的特性，可以查到在 babel6 且 corejs2 以上支持，在 chrome 中是 49 以上支持，chrome48 中还是实验特性，在 node6 以上支持，等等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1adc5fc56d4ec1ad4cb757eb3356c5~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>光是这些数据还不够，electron 有自己的版本，要支持 electron 得需要 electron 版本和它用的 chromuim 的版本的对应关系。</p>
<p>万幸有 electron-to-chromium 这个项目，它维护了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKilian%2Felectron-to-chromium%2Fblob%2Fmaster%2Ffull-versions.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js" ref="nofollow noopener noreferrer">electron 版本到 chromium 版本的映射关系</a>。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e37c9049544f429cd2a48afb434a81~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>也可以反过来查询 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKilian%2Felectron-to-chromium%2Fblob%2Fmaster%2Ffull-chromium-versions.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Kilian/electron-to-chromium/blob/master/full-chromium-versions.js" ref="nofollow noopener noreferrer">chromium 版本在哪些 electron 版本中使用</a>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d759abbb6a8f422aa791f6ce6e2dd918~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>有了这些数据，我们就能知道每一个特性在哪些环境的什么版本支持。</p>
<p>babel7 在 @babel/compat-data 这个包里面维护了这种特性到环境支持版本的映射关系，包括 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-compat-data%2Fdata%2Fplugins.json" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/plugins.json" ref="nofollow noopener noreferrer">plugin 实现的特性的版本支持情况</a>（包括 transform 和 proposal ），也包括 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-compat-data%2Fdata%2Fcorejs2-built-ins.json" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/corejs2-built-ins.json" ref="nofollow noopener noreferrer">corejs 所 polyfill 的特性的版本支持情况</a>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ed0641db8a4547a8c857306c22e286~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>这样我们就知道每一个特性是在什么环境中支持的了，接下来只要用户指定一个环境，我们就能做到按需转换！</p>
<h5 data-id="heading-2">browserslist</h5>
<p>那开发者怎么指定环境呢？</p>
<p>让开发者写每个环境的版本是啥肯定不靠谱，这时候就要借助 browerslist 了，它提供了一个从 query （查询表达式） 到对应环境版本的转换。</p>
<p>比如我们可以通过 last 1 version 来查询最新的各环境的版本</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6aa23bc2102480894c72916418b3eb1~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>也可以通过 supports es6-module 查询所有支持 es module 的环境版本</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1cf4c0f5294a268043e03e0d866327~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>具体查询的语法有很多，可以去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist%23queries" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/browserslist/browserslist#queries" ref="nofollow noopener noreferrer">browserslist 的 query 文档</a>中学习，这里就不展开了。</p>
<h5 data-id="heading-3">@babel/preset-env</h5>
<p>现在有了什么特性在什么环境版本中支持，有了可以通过 query 指定目标环境版本的工具，那么就可以上手改了，从都转成 es5 到根据目标环境确定不支持的特性，只转换这部分特性，这就是 @babel/preset-env 做的事情。</p>
<p>有了 @babel/compat-data 的数据，那么只要用户指定他的目标环境是啥就可以了，这时候可以用 browserslist 的 query 来写，比如 <code>last 1 version, &gt; 1%</code> 这种字符串，babel 会使用 brwoserslist 来把它们转成目标环境具体版本的数据。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a318db95f7cb4f139981f2f453bdc39e~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>有了不同特性支持的环境的最低版本的数据，有了具体的版本，那么过滤出来的就是目标环境不支持的特性，然后引入它们对应的插件即可。这就是 preset-env 做的事情(按照目标环境按需引入插件)。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ccb1144f8924fb99cc6073859289124~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>配置方式比如：</p>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-string">"presets"</span>: [[<span class="hljs-string">"@babel/preset-env"</span>, { <span class="hljs-string">"targets"</span>: <span class="hljs-string">"&gt; 0.25%, not dead"</span> }]]
}
</code></pre>
<p>这样就通过 preset-env 解决了多转换了目标环境已经支持的特性的问题。</p>
<p>其实 polyfill 也可以通过 targets 来过滤。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8df3916feb4da7b445e8771e779353~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>不再手动引入 polyfill，那么怎么引入？ 当然是用 preset-env 自动引入了。但是不是默认就会启用这个功能，需要配置。</p>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-string">"presets"</span>: [[<span class="hljs-string">"@babel/preset-env"</span>, { 
        <span class="hljs-string">"targets"</span>: <span class="hljs-string">"&gt; 0.25%, not dead"</span>,
        <span class="hljs-string">"useBuiltIns"</span>: <span class="hljs-string">"usage"</span>,<span class="hljs-comment">// or "entry" or "false"</span>
        <span class="hljs-string">"corejs"</span>: <span class="hljs-number">3</span>
    }]]
}
</code></pre>
<p>配置下 corejs 和 useBuiltIns。</p>
<ul>
<li>
<p>corejs 就是 babel 7 所用的 polyfill，需要指定下版本，corejs 3 才支持实例方法（比如 Array.prototype.fill ）的 polyfill。</p>
</li>
<li>
<p>useBuiltIns 就是使用 polyfill （corejs）的方式，是在入口处全部引入（entry），还是每个文件引入用到的（usage），或者不引入（false）。</p>
</li>
</ul>
<p>配置了这两个 option 就可以自动引入 polyfill 了。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea48ded51f04512bac80b8e4db809cb~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<h4 data-id="heading-4">@babel/preset-env 的配置</h4>
<p>这个包的配置比较多，首先我们要指定的是 targets，也就是 browserslist 的 query，这个同样可以在 .browserslistrc 的配置文件中指定（别的工具也可能用到）。</p>
<h5 data-id="heading-5">targets</h5>
<p>targets 配啥呢？</p>
<p>可以配 query 或者直接指定环境版本（query 的结果也是环境版本）。</p>
<p>环境有这些：</p>
<p>chrome, opera, edge, firefox, safari, ie, ios, android, node, electron</p>
<p>可以指定 query：</p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-string">"targets"</span>: <span class="hljs-string">"&gt; 0.25%, not dead"</span>
}
</code></pre>
<p>也可以直接指定环境版本；</p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-string">"targets"</span>: {
    <span class="hljs-string">"chrome"</span>: <span class="hljs-string">"58"</span>,
    <span class="hljs-string">"ie"</span>: <span class="hljs-string">"11"</span>
  }
}
</code></pre>
<p>要指定支持 es module 的环境，可以使用 query，也可以使用 esmodules option。</p>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-string">"targets"</span>: {
        <span class="hljs-string">"esmodules"</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
<h5 data-id="heading-6">include &amp; exclude</h5>
<p>通过 targets 的指定，babel 会自动引入<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmaster%2Fpackages%2Fbabel-compat-data%2Fscripts%2Fdata%2Fplugin-features.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js" ref="nofollow noopener noreferrer">一些插件</a>，但当需要手动指定要 include 或者 exclude 什么插件的时候可以使用这个 option。</p>
<p>不过这个只是针对 transform plugin，对于 proposal plugin，要在 plugins的 option 单独引入。</p>
<p>一般情况下并不需要单独 include 啥，用 babel 根据 targets 自动引入的 transform plugin 即可，只是有一些特殊场景下可能会用到。</p>
<h5 data-id="heading-7">modules</h5>
<p>targets 是指定目标环境，modules 是指定目标模块规范，取值有 amd、umd、systemjs、commonjs (cjs)、auto、false。</p>
<ul>
<li>
<p>amd、umd、systemjs、commonjs (cjs) 这四个分别指定不同的目标模块规范</p>
</li>
<li>
<p>false 是不转换模块规范</p>
</li>
<li>
<p>auto 则是自动探测，默认值也是这个。</p>
</li>
</ul>
<p>其实一般这个 option 都是 bundler 来设置的，因为 bundler 负责模块转换，自然知道要转换成什么模块规范。我们平时就用默认值 auto 即可。</p>
<p>类似 babel parser 可以设置 moduleType 为 unambiguous，让 babel 根据是否包含 import / export 语法来自动设置为具体的值。 这个 auto 也是一样，会根据探测到的目标环境支持的模块规范来做转换。依据是在 transform 的时候传入的 caller 数据。</p>
<pre><code class="hljs language-javascript" lang="javascript">babel.transformFileSync(<span class="hljs-string">"example.js"</span>, {
  <span class="hljs-attr">caller</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"my-custom-tool"</span>,
    <span class="hljs-attr">supportsStaticESM</span>: <span class="hljs-literal">true</span>,
  },
});
</code></pre>
<p>比如在调用 transformFile 的 api 的时候传入了 caller 是支持 esm 的，那么在 targets 的 modules 就会自动设置为 esm。</p>
<h5 data-id="heading-8">debug</h5>
<p>debug 这个参数配置比较简单，就是 true 或者 false，但是意义却很大。我们知道 babel 会根据 targets 支持的特性来过滤 transform plugins 和 polyfills（core-js）。想知道最终使用的 transform plugin 和引入的 core-js 模块是否对，那就可以把 debug 设为 true，这样在控制台打印这些数据。</p>
<p>比如</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">`
  import "core-js";
  new Array(5).fill('111');
`</span>;

<span class="hljs-keyword">const</span> { code, map } = babel.transformSync(sourceCode, {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'a.mjs'</span>,
    <span class="hljs-attr">targets</span>: {
        <span class="hljs-attr">browsers</span>: <span class="hljs-string">'Chrome 45'</span>,
    },
    <span class="hljs-attr">presets</span>: [
        [<span class="hljs-string">'@babel/env'</span>, {
            <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">'usage'</span>,
            <span class="hljs-attr">corejs</span>: <span class="hljs-number">3</span>
        }]
    ]
});

</code></pre>
<p>设置 debug 为 true，会打印 targets 和根据 tragets 过滤出的的 plugin 和 preset：</p>
<pre><code class="">@babel/preset-env: `DEBUG` option

Using targets:
{
  "chrome": "45"
}

Using modules transform: auto

Using plugins:
  proposal-numeric-separator { chrome &lt; 75 }
  proposal-logical-assignment-operators { chrome &lt; 85 }
  proposal-nullish-coalescing-operator { chrome &lt; 80 }
  proposal-optional-chaining { chrome }
  proposal-json-strings { chrome &lt; 66 }
  proposal-optional-catch-binding { chrome &lt; 66 }
  transform-parameters { chrome &lt; 49 }
  proposal-async-generator-functions { chrome &lt; 63 }
  proposal-object-rest-spread { chrome &lt; 60 }
  transform-dotall-regex { chrome &lt; 62 }
  proposal-unicode-property-regex { chrome &lt; 64 }
  transform-named-capturing-groups-regex { chrome &lt; 64 }
  transform-async-to-generator { chrome &lt; 55 }
  transform-exponentiation-operator { chrome &lt; 52 }
  transform-function-name { chrome &lt; 51 }
  transform-arrow-functions { chrome &lt; 47 }
  transform-classes { chrome &lt; 46 }
  transform-object-super { chrome &lt; 46 }
  transform-for-of { chrome &lt; 51 }
  transform-sticky-regex { chrome &lt; 49 }
  transform-unicode-regex { chrome &lt; 50 }
  transform-spread { chrome &lt; 46 }
  transform-destructuring { chrome &lt; 51 }
  transform-block-scoping { chrome &lt; 49 }
  transform-new-target { chrome &lt; 46 }
  transform-regenerator { chrome &lt; 50 }
  proposal-export-namespace-from { chrome &lt; 72 }
  transform-modules-commonjs
  proposal-dynamic-import
corejs3: `DEBUG` option

Using targets: {
  "chrome": "45"
}

Using polyfills with `usage-global` method:
regenerator: `DEBUG` option

Using targets: {
  "chrome": "45"
}

Using polyfills with `usage-global` method:

  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.
  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.

[/Users/zhaixuguang/code/research/babel/a.mjs]
Based on your code and targets, the corejs3 polyfill did not add any polyfill.

[/Users/zhaixuguang/code/research/babel/a.mjs]
Based on your code and targets, the regenerator polyfill did not add any polyfill.

</code></pre>
<p>用到了哪些插件一目了然，开发时可以开启这个配置项。</p>
<p>更多配置项可以在<a href="https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-preset-env%23options" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-preset-env#options" ref="nofollow noopener noreferrer">文档中</a>查看。</p>
<h2 data-id="heading-9">从注入到抽离</h2>
<p>preset-env 会在使用到新特性的地方注入 helper 到 AST 中，并且会引入用到的特性的 polyfill （corejs + regenerator），这样会导致两个问题：</p>
<ul>
<li>重复注入 helper 的实现，导致代码冗余</li>
<li>polyfill 污染全局环境</li>
</ul>
<p>解决这两个问题的思路就是抽离出来，然后作为模块引入，这样多个模块复用同一份代码就不会冗余了，而且 polyfill 是模块化引入的也不会污染全局环境。</p>
<p>这个逻辑是在 @babel/plugin-transform-runtime 包里实现的。它可以把直接注入全局的方式改成模块化引入。</p>
<p>比如使用 preset-env 的时候是全局引入的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea48ded51f04512bac80b8e4db809cb~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>当引入 @babel/plugin-transform-runtime 就可以模块化引入：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64df84f32f6945c19bac48cc7185dee7~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>这样就不再污染全局环境了。</p>
<h3 data-id="heading-10">babel7 的问题</h3>
<p>我们先来试验一下：</p>
<p>看一下 Array.prototype.fill 的环境支持情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cae7d0873384728a404963eff4861c4~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>可以看到在 Chrome 45 及以上支持这个特性，而在 Chrome 44 就不支持了。</p>
<p>我们先单独试一下 preset-env：</p>
<p>当指定 targets 为 Chrome 44 时，应该自动引入polyfill：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d43b57304a4d2f9f64af086f5d6098~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>当指定 targets 为 Chrome 45 时，不需要引入polyfill：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f68b5ad95f644518c8419c1847f7765~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>结果都符合预期，44 引入，45 不引入。</p>
<p>我们再来试试 @babel/plugin-transform-runtime：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9677f1aaba654728aec933b31e632fe0~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>是不是发现问题了，Chrome 45 不是支持 Array.prototype.fill 方法么，为啥还是引入了 polyfill。</p>
<p>因为 babel 中插件的应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左，这样 plugin-transform-runtime 是在 preset-env 前面的。等 @babel/plugin-transform-runtime 转完了之后，再交给 preset-env 这时候已经做了无用的转换了。而 @babel/plugin-transform-runtime 并不支持 targets 的配置，就会做一些多余的转换和 polyfill。</p>
<p>这个问题在即将到来的 babel8 中得到了解决。</p>
<h3 data-id="heading-11">babel8</h3>
<p>babel8 提供了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel-polyfills" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel-polyfills" ref="nofollow noopener noreferrer">一系列 babel polyfill 的包 </a>  ，解决了 babel7 的 @babel/plugin-transform-runtime 的遗留问题，可以通过 targets 来按需精准引入 polyfill。</p>
<p>babel8 支持配置一个 polyfill provider，也就是说你可以指定 corejs2、corejs3、es-shims 等 polyfill，还可以自定义 polyfil。</p>
<p>有了 polyfill 源之后，使用 polyfill 的方式也把之前 transform-runtime 做的事情内置了，从之前的 useBuiltIns: entry、 useBuiltIns: usage 的两种，变成了 3 种：</p>
<ul>
<li>entry-global: 这个和之前的 useBuiltIns: entry 对标，就是全局引入 polyfill。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202c38690dfe455b8c033d6e54ede9b2~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<ul>
<li>usage-entry: 这个和 useBuiltIns: usage 对标，就是具体模块引入用到的 polyfill。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d206affa374e53a786592e6a0cfa6e~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<ul>
<li>usage-pure：这个就是之前需要 transform-runtime 插件做的事情，使用不污染全局变量的 pure 的方式引入具体模块用到的 polyfill.</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c65f9672d34c04814142bf04ccc8b9~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>其实这三种方式 babel 7 也支持，但是 babel8 不再需要 transform-runtime 插件了，而且还支持了 polyfill provider 的配置。</p>
<h2 data-id="heading-12">思路梳理</h2>
<p>babel 的功能都是通过插件完成的，但是直接指定插件太过麻烦，所以设计出了 preset，我们学习 babel 的内置功能基本等价于学习 preset 的使用。主要是 preset-env、preset-typescript 这些。</p>
<p>但是一些 proposal 的插件需要单独引入，并且 @babel/plugin-transform-runtime也要单独引入。</p>
<p>学习内置功能的话 preset 是重点，但是最终完成功能的还是通过插件。小册的重点在于插件上，介绍内置的 preset 只是梳理下 babel 实现编译的思路。</p>
<h2 data-id="heading-13">总结</h2>
<p>上一节我们基于 plugin 和 preset 已经能够完成 esnext 等代码转目标环境 js 代码的功能，但是还不完美。</p>
<p>这一节我们介绍了 @babel/preset-env，它基于每种特性的在不同环境的最低支持版本的数据和配置的 targets 来过滤插件，这样能减少很多没必要的转换和 polyfill。</p>
<p>如果希望把一些公共的 helper、core-js、regenerator 等注入的 runtime 函数抽离出来，并且以模块化的方式引入，那么需要用 @babel/plugin-transform-runtime 这个包。</p>
<p>@babel/plugin-transform-runtime 不支持根据 targets 的过滤，和 @babel/preset-env 配合时有问题，这个在 babel8 中得到了解决。babel8 提供了很多 babel polyfill 包，支持了 polyfill provider 的配置，而且还可以选择注入方式。不再需要 @babel/plugin-transform-runtime 插件了。</p>
<p>学完这一节，我们知道了 babel 如何基于数据做到精准的转换，如何设计 preset，这对我们设计 preset 或许也有一些启发。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>