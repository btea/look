<style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>babel 能够做静态分析，分析代码然后得出一些信息。我们经常用的打包工具就需要通过静态分析的方式得出模块间的依赖关系，然后构造成依赖图，之后对这个依赖图做各种处理，最后输出成文件。</p>
<p>比如 webpack 的打包过程：从入口模块分析依赖，构造模块依赖图，然后把一些模块合并到同个分组（chunk）里，生成 chunk 依赖图，最后把 chunk 通过模版打印为 assets，输出为文件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad6cc6cb7e84f3da779adf1f79a773d~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>从入口模块开始，对每个模块的依赖关系的分析就是基于 AST，这种就可以用 babel parser （或者直接用 acorn）来处理。</p>
<p>这一节我们就来实现下依赖分析的功能，也就是遍历所有的模块。</p>
<p>写这个的好处一个是能够加深我们对打包工具的认识，二是当做一些独立的工具的时候，可能也需要分析模块依赖关系。</p>
<h2 data-id="heading-0">思路分析</h2>
<p>模块依赖分析也就是要分析 import 和 export，从入口模块开始，读取文件内容，通过 babel parser 把内容 parse 成 ast，之后通过 babel traverse 来对 AST 进行遍历。分别对 ImportDeclaration、ExportDeclaration 做处理：</p>
<p>ImportDeclaration：收集 import 信息，确定依赖的模块和引入的变量，之后再递归处理该模块
ExportDeclaration：收集 export 信息，确定导出的变量</p>
<p>我们可以设计这样一个结构来表示每个模块的信息：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyNode</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">path = <span class="hljs-string">''</span>, imports = {}, <span class="hljs-built_in">exports</span> = []</span>)</span> {
        <span class="hljs-built_in">this</span>.path = path;
        <span class="hljs-built_in">this</span>.imports = imports;
        <span class="hljs-built_in">this</span>.exports = <span class="hljs-built_in">exports</span>;
        <span class="hljs-built_in">this</span>.subModules = {};
    }
}
</code></pre>
<p>path 表示当前模块路径， imports 表示从什么模块引入了什么变量，exports 表示导出了什么变量。</p>
<p>接下来我们要完成 traverseModule 这个方法，也就是对每个模块的处理</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> dependencyGraph = traverseModule(入口模块路径);
</code></pre>
<p>具体处理的过程就是：</p>
<ul>
<li>读取文件内容</li>
<li>通过 babel parser 把文件内容 parse 成 ast</li>
<li>遍历 AST，对 ImportDeclaration、ExportDeclaration 分别做处理</li>
<li>对分析出的依赖路径进行处理，变成绝对路径，并尝试补全</li>
<li>递归处理分析出来的依赖路径</li>
</ul>
<p>如果没有后缀名的依赖路径，要分别尝试 .js、.jsx、.ts、.tsx 的路径，如果存在就补全成该路径，并且目录还要补全 index 文件名。</p>
<p>通过递归处理依赖模块，就可以完成依赖图的构建，我们可以保存根节点和所有模块的信息：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> dependencyGraph = {
    <span class="hljs-attr">root</span>: <span class="hljs-keyword">new</span> DependencyNode(),
    <span class="hljs-attr">allModules</span>: {}
};
</code></pre>
<p>当处理完所有模块后，就得到了完整的 dependencyGraph。</p>
<p>接下来我们来写下代码。</p>
<h2 data-id="heading-1">代码实现</h2>
<p>首先我们定义要返回的 dependencyGraph，</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyNode</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">path = <span class="hljs-string">''</span>, imports = {}, <span class="hljs-built_in">exports</span> = []</span>)</span> {
        <span class="hljs-built_in">this</span>.path = path;
        <span class="hljs-built_in">this</span>.imports = imports;
        <span class="hljs-built_in">this</span>.exports = <span class="hljs-built_in">exports</span>;
        <span class="hljs-built_in">this</span>.subModules = {};
    }
}

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">curModulePath</span>) </span>{
    <span class="hljs-keyword">const</span> dependencyGraph = {
        <span class="hljs-attr">root</span>: <span class="hljs-keyword">new</span> DependencyNode(),
        <span class="hljs-attr">allModules</span>: {}
    };
    traverseJsModule(curModulePath, dependencyGraph.root, dependencyGraph.allModules);
    <span class="hljs-keyword">return</span> dependencyGraph;
}
</code></pre>
<p>接下来实现遍历的方法，也就是之前分析的 <strong>读取文件内容、parse 成 AST、travese AST 提取模块信息和依赖信息、递归遍历依赖（先把路径处理成绝对路径）</strong> 的过程。</p>
<blockquote>
<p>要注意的是，ts、jsx、tsx 等用的 babel 插件不同，要根据 extname 来做不同的插件的引入。</p>
</blockquote>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveBabelSyntaxtPlugins</span>(<span class="hljs-params">modulePath</span>) </span>{
    <span class="hljs-keyword">const</span> plugins = [];
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">'.tsx'</span>, <span class="hljs-string">'.jsx'</span>].some(<span class="hljs-function"><span class="hljs-params">ext</span> =&gt;</span> modulePath.endsWith(ext))) {
        plugins.push(<span class="hljs-string">'jsx'</span>);
    }
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">'.ts'</span>, <span class="hljs-string">'.tsx'</span>].some(<span class="hljs-function"><span class="hljs-params">ext</span> =&gt;</span> modulePath.endsWith(ext))) {
        plugins.push(<span class="hljs-string">'typescript'</span>);
    }
    <span class="hljs-keyword">return</span> plugins;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseJsModule</span>(<span class="hljs-params">curModulePath, dependencyGrapthNode, allModules</span>) </span>{
    <span class="hljs-keyword">const</span> moduleFileContent = fs.readFileSync(curModulePath, {
        <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span>
    });
    dependencyGrapthNode.path = curModulePath;

    <span class="hljs-keyword">const</span> ast = parser.parse(moduleFileContent, {
        <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'unambiguous'</span>,
        <span class="hljs-attr">plugins</span>: resolveBabelSyntaxtPlugins(curModulePath)
    });

    traverse(ast, {
        <span class="hljs-function"><span class="hljs-title">ImportDeclaration</span>(<span class="hljs-params">path</span>)</span> {
            <span class="hljs-comment">// 收集import 信息</span>
            <span class="hljs-comment">// 递归处理依赖模块</span>
            traverseJsModule(subModulePath, subModule, allModules);
            dependencyGrapthNode.subModules[subModule.path] = subModule;
        },
        <span class="hljs-function"><span class="hljs-title">ExportDeclaration</span>(<span class="hljs-params">path</span>)</span> {
            <span class="hljs-comment">//收集 export 信息</span>
        }
    });
    allModules[curModulePath] = dependencyGrapthNode;
}
</code></pre>
<p>上面省略了对 ImportDeclaration 和 ExportDeclaration 的处理，接下来我们来分别处理下这两种节点：</p>
<p>ImportDeclaration 分为三种：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 这种我们叫 deconstruct import（解构引入）</span>
<span class="hljs-keyword">import</span> { a, b <span class="hljs-keyword">as</span> bb} <span class="hljs-keyword">from</span> <span class="hljs-string">'aa'</span>;
<span class="hljs-comment">// 这种我们叫 namespace import（命名空间引入）</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">'cc'</span>;
<span class="hljs-comment">// 这种我们叫 default import（默认引入）</span>
<span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">'b'</span>;
</code></pre>
<p>那么我们就要根据具体的类型来提取信息：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> IMPORT_TYPE = {
    <span class="hljs-attr">deconstruct</span>: <span class="hljs-string">'deconstruct'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'default'</span>,
    <span class="hljs-attr">namespace</span>: <span class="hljs-string">'namespace'</span>
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"> <span class="hljs-function"><span class="hljs-title">ImportDeclaration</span>(<span class="hljs-params">path</span>)</span> {
    <span class="hljs-keyword">const</span> subModulePath = moduleResolver(curModulePath, path.get(<span class="hljs-string">'source.value'</span>).node);
    <span class="hljs-keyword">if</span> (!subModulePath) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> specifierPaths = path.get(<span class="hljs-string">'specifiers'</span>);
    dependencyGrapthNode.imports[subModulePath] = specifierPaths.map(<span class="hljs-function"><span class="hljs-params">specifierPath</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (specifierPath.isImportSpecifier()) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: IMPORT_TYPE.deconstruct,
                <span class="hljs-attr">imported</span>: specifierPath.get(<span class="hljs-string">'imported'</span>).node.name,
                <span class="hljs-attr">local</span>: specifierPath.get(<span class="hljs-string">'local'</span>).node.name
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (specifierPath.isImportDefaultSpecifier()) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: IMPORT_TYPE.default,
                <span class="hljs-attr">local</span>: specifierPath.get(<span class="hljs-string">'local'</span>).node.name
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">type</span>: IMPORT_TYPE.namespace,
                <span class="hljs-attr">local</span>: specifierPath.get(<span class="hljs-string">'local'</span>).node.name
            }
        }
    });

    <span class="hljs-keyword">const</span> subModule = <span class="hljs-keyword">new</span> DependencyNode();
    traverseJsModule(subModulePath, subModule, allModules);
    dependencyGrapthNode.subModules[subModule.path] = subModule;
}
</code></pre>
<p>上面我们通过记录了 import 信息到  dependencyGrapthNode.imports 中，并且递归处理了依赖模块。而且在处理依赖模块之前，我们做了把路径转成绝对路径和路径补全的处理。</p>
<p>路径补全的处理就是分别尝试 .tsx,.ts,.jsx,.js的路径是否存在，如果是目录的话，还要连同 index 一起补全，也就是 index.tsx、index.ts、index.jsx、index.js</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeModulePath</span> (<span class="hljs-params">modulePath</span>) </span>{
    <span class="hljs-keyword">const</span> EXTS = [<span class="hljs-string">'.tsx'</span>,<span class="hljs-string">'.ts'</span>,<span class="hljs-string">'.jsx'</span>,<span class="hljs-string">'.js'</span>];
    <span class="hljs-keyword">if</span> (modulePath.match(<span class="hljs-regexp">/\.[a-zA-Z]+$/</span>)) {
        <span class="hljs-keyword">return</span> modulePath;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryCompletePath</span> (<span class="hljs-params">resolvePath</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; EXTS.length; i ++) {
            <span class="hljs-keyword">let</span> tryPath = resolvePath(EXTS[i]);
            <span class="hljs-keyword">if</span> (fs.existsSync(tryPath)) {
                <span class="hljs-keyword">return</span> tryPath;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportModuleNotFoundError</span> (<span class="hljs-params">modulePath</span>) </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'module not found: '</span> + modulePath;
    }

    <span class="hljs-keyword">if</span> (isDirectory(modulePath)) {<span class="hljs-comment">//如果是目录</span>
        <span class="hljs-keyword">const</span> tryModulePath = tryCompletePath(<span class="hljs-function">(<span class="hljs-params">ext</span>) =&gt;</span> path.join(modulePath, <span class="hljs-string">'index'</span> + ext));
        <span class="hljs-keyword">if</span> (!tryModulePath) {
            reportModuleNotFoundError(modulePath);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> tryModulePath;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!EXTS.some(<span class="hljs-function"><span class="hljs-params">ext</span> =&gt;</span> modulePath.endsWith(ext))) {<span class="hljs-comment">//如果补全后的路径存在</span>
        <span class="hljs-keyword">const</span> tryModulePath = tryCompletePath(<span class="hljs-function">(<span class="hljs-params">ext</span>) =&gt;</span> modulePath + ext);
        <span class="hljs-keyword">if</span> (!tryModulePath) {
            reportModuleNotFoundError(modulePath);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> tryModulePath;
        }
    }
    <span class="hljs-keyword">return</span> modulePath;
}
</code></pre>
<p>当然，我们还要收集下 export 的信息，也是分为三种类型：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 全部导出(all export)</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'a'</span>;
<span class="hljs-comment">// 默认导出 (default export)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> b;
<span class="hljs-comment">// 命名导出 (named export)</span>
<span class="hljs-keyword">export</span> { c <span class="hljs-keyword">as</span> cc };
</code></pre>
<p>然后分别对这三种 AST 做不同的信息收集：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-function"><span class="hljs-title">ExportDeclaration</span>(<span class="hljs-params">path</span>)</span> {
    <span class="hljs-keyword">if</span>(path.isExportNamedDeclaration()) {
        <span class="hljs-keyword">const</span> specifiers = path.get(<span class="hljs-string">'specifiers'</span>);
        dependencyGrapthNode.exports = specifiers.map(<span class="hljs-function"><span class="hljs-params">specifierPath</span> =&gt;</span> ({
            <span class="hljs-attr">type</span>: EXPORT_TYPE.named,
            <span class="hljs-attr">exported</span>: specifierPath.get(<span class="hljs-string">'exported'</span>).node.name,
            <span class="hljs-attr">local</span>: specifierPath.get(<span class="hljs-string">'local'</span>).node.name
        }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path.isExportDefaultDeclaration()) {
        <span class="hljs-keyword">let</span> exportName;
        <span class="hljs-keyword">const</span> declarationPath = path.get(<span class="hljs-string">'declaration'</span>);
        <span class="hljs-keyword">if</span>(declarationPath.isAssignmentExpression()) {
            exportName = declarationPath.get(<span class="hljs-string">'left'</span>).toString();
        } <span class="hljs-keyword">else</span> {
            exportName = declarationPath.toString()
        }
        dependencyGrapthNode.exports.push({
            <span class="hljs-attr">type</span>: EXPORT_TYPE.default,
            <span class="hljs-attr">exported</span>: exportName
        });
    } <span class="hljs-keyword">else</span> {
        dependencyGrapthNode.exports.push({
            <span class="hljs-attr">type</span>: EXPORT_TYPE.all,
            <span class="hljs-attr">exported</span>: path.get(<span class="hljs-string">'exported'</span>).node.name,
            <span class="hljs-attr">source</span>: path.get(<span class="hljs-string">'source'</span>).node.value
        });
    }
}
</code></pre>
<p>递归处理每一个模块就完成了依赖图的构建。</p>
<h2 data-id="heading-2">效果演示</h2>
<p>首先我们写一个测试项目：</p>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { aa1, aa2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./a'</span>;

<span class="hljs-built_in">console</span>.log(aa1);
</code></pre>
<p><strong>a.js</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">'./b'</span>;

<span class="hljs-keyword">const</span> aa1 = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> aa2 = <span class="hljs-number">2</span>;

<span class="hljs-built_in">console</span>.log(b);

<span class="hljs-keyword">export</span> {
    aa1,
    aa2
}
</code></pre>
<p><strong>b.js</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { cc  <span class="hljs-keyword">as</span> renamedCc } <span class="hljs-keyword">from</span> <span class="hljs-string">'./c'</span>;
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> b = <span class="hljs-number">4</span>;

</code></pre>
<p><strong>c/index.js</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> cc = <span class="hljs-number">5</span>;

<span class="hljs-keyword">export</span> {
    cc
};
</code></pre>
<p>然后使用 traverseModule 方法对入口模块 index 进行处理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> traverseModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./traverseModule'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">const</span> dependencyGraph = traverseModule(path.resolve(__dirname, <span class="hljs-string">'../test-project/index.js'</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(dependencyGraph, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>));
</code></pre>
<p>结果如下，我们成功构建出了整个依赖图：</p>
<pre><code class="">{
    "root": {
        "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/index.js",
        "imports": {
            "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js": [
                {
                    "type": "deconstruct",
                    "imported": "aa1",
                    "local": "aa1"
                },
                {
                    "type": "deconstruct",
                    "imported": "aa2",
                    "local": "aa2"
                }
            ]
        },
        "exports": [],
        "subModules": {
            "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js": {
                "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js",
                "imports": {
                    "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": [
                        {
                            "type": "default",
                            "local": "b"
                        }
                    ]
                },
                "exports": [
                    {
                        "type": "named",
                        "exported": "aa1",
                        "local": "aa1"
                    },
                    {
                        "type": "named",
                        "exported": "aa2",
                        "local": "aa2"
                    }
                ],
                "subModules": {
                    "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": {
                        "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js",
                        "imports": {
                            "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": [
                                {
                                    "type": "deconstruct",
                                    "imported": "cc",
                                    "local": "renamedCc"
                                }
                            ]
                        },
                        "exports": [
                            {
                                "type": "default",
                                "exported": "b"
                            }
                        ],
                        "subModules": {
                            "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": {
                                "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js",
                                "imports": {},
                                "exports": [
                                    {
                                        "type": "named",
                                        "exported": "cc",
                                        "local": "cc"
                                    }
                                ],
                                "subModules": {}
                            }
                        }
                    }
                }
            }
        }
    },
    "allModules": {
        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": {
            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js",
            "imports": {},
            "exports": [
                {
                    "type": "named",
                    "exported": "cc",
                    "local": "cc"
                }
            ],
            "subModules": {}
        },
        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": {
            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js",
            "imports": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": [
                    {
                        "type": "deconstruct",
                        "imported": "cc",
                        "local": "renamedCc"
                    }
                ]
            },
            "exports": [
                {
                    "type": "default",
                    "exported": "b"
                }
            ],
            "subModules": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": {
                    "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js",
                    "imports": {},
                    "exports": [
                        {
                            "type": "named",
                            "exported": "cc",
                            "local": "cc"
                        }
                    ],
                    "subModules": {}
                }
            }
        },
        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js": {
            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js",
            "imports": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": [
                    {
                        "type": "default",
                        "local": "b"
                    }
                ]
            },
            "exports": [
                {
                    "type": "named",
                    "exported": "aa1",
                    "local": "aa1"
                },
                {
                    "type": "named",
                    "exported": "aa2",
                    "local": "aa2"
                }
            ],
            "subModules": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": {
                    "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js",
                    "imports": {
                        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": [
                            {
                                "type": "deconstruct",
                                "imported": "cc",
                                "local": "renamedCc"
                            }
                        ]
                    },
                    "exports": [
                        {
                            "type": "default",
                            "exported": "b"
                        }
                    ],
                    "subModules": {
                        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": {
                            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js",
                            "imports": {},
                            "exports": [
                                {
                                    "type": "named",
                                    "exported": "cc",
                                    "local": "cc"
                                }
                            ],
                            "subModules": {}
                        }
                    }
                }
            }
        },
        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/index.js": {
            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/index.js",
            "imports": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js": [
                    {
                        "type": "deconstruct",
                        "imported": "aa1",
                        "local": "aa1"
                    },
                    {
                        "type": "deconstruct",
                        "imported": "aa2",
                        "local": "aa2"
                    }
                ]
            },
            "exports": [],
            "subModules": {
                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js": {
                    "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/a.js",
                    "imports": {
                        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": [
                            {
                                "type": "default",
                                "local": "b"
                            }
                        ]
                    },
                    "exports": [
                        {
                            "type": "named",
                            "exported": "aa1",
                            "local": "aa1"
                        },
                        {
                            "type": "named",
                            "exported": "aa2",
                            "local": "aa2"
                        }
                    ],
                    "subModules": {
                        "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js": {
                            "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/b.js",
                            "imports": {
                                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": [
                                    {
                                        "type": "deconstruct",
                                        "imported": "cc",
                                        "local": "renamedCc"
                                    }
                                ]
                            },
                            "exports": [
                                {
                                    "type": "default",
                                    "exported": "b"
                                }
                            ],
                            "subModules": {
                                "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js": {
                                    "path": "/Users/guang/code/babel-plugin-exercize/exercize-module-iterator/test-project/c/index.js",
                                    "imports": {},
                                    "exports": [
                                        {
                                            "type": "named",
                                            "exported": "cc",
                                            "local": "cc"
                                        }
                                    ],
                                    "subModules": {}
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<p>有了依赖图之后，就可以做进一步的处理，比如：</p>
<ul>
<li>合并一些模块成 chunk graph</li>
<li>通过 export 和 import 的关系的分析，实现 treeshking</li>
</ul>
<h2 data-id="heading-3">总结</h2>
<p>打包工具 webpack 就是基于 AST 来做的依赖分析，通过构建模块依赖图，之后进一步的处理。这节我们基于 babel parser 和 babel traverse 做了模块的遍历和依赖图的生成。</p>
<p>每个模块的处理都是 <strong>读取内容、parse、遍历 AST提取 import 和 export 信息、递归遍历依赖</strong> 的过程。</p>
<p>其中要注意的是parse 的插件要根据后缀名来决定，路径要做下补全。</p>
<p>遍历 AST 是要确定什么属性，遍历模块则是要解析 require，然后处理路径。</p>
<p>依赖图分析完之后就可以做进一步的处理，比如合并 chunk、treeshking 等，然后输出成文件，这就是打包工具。</p>
<p>（代码在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQuarkGluonPlasma%2Fbabel-plugin-exercize" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/QuarkGluonPlasma/babel-plugin-exercize" ref="nofollow noopener noreferrer">这里</a>，建议 git clone 下来通过 node 跑一下）</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>