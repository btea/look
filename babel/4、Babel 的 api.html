<style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>学习了 babel 的编译流程和 AST 之后，我们来学习下 babel 的 api，通过这些 api 来操作 AST，完成代码的转换。</p>
<blockquote>
<p>注意，我们学习的 api 是 babel 7.x 的，babel 6 的 api 还没有按照 scope 来划分，是 babel-parser 这种，而 babel 7 变成了@babel/parser 这种。但具体 api 差不多，我们学的是一些原理性的东西，这些东西在版本迭代中是不会变的。</p>
</blockquote>
<h2 data-id="heading-0">babel 的 api 有哪些</h2>
<p>我们知道 babel 的编译流程分为三步：parse、transform、generate，每一步都暴露了一些 api 出来。</p>
<ul>
<li>parse 阶段有<code>@babel/parser</code>，功能是把源码转成 AST</li>
<li>transform 阶段有 <code>@babel/traverse</code>，可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 <code>@babel/types</code> 了，当需要批量创建 AST 的时候可以使用  <code>@babel/template</code> 来简化 AST 创建逻辑。</li>
<li>generate 阶段会把 AST 打印为目标代码字符串，同时生成 sourcemap，需要 <code>@babel/generate</code> 包</li>
<li>中途遇到错误想打印代码位置的时候，使用 <code>@babel/code-frame</code> 包</li>
<li>babel 的整体功能通过 <code>@babel/core</code> 提供，基于上面的包完成 babel 整体的编译流程，并实现插件功能。</li>
</ul>
<p>我们主要学习的就是 <code>@babel/parser</code>，<code>@babel/traverse</code>，<code>@babel/generator</code>，<code>@babel/types</code>，<code>@babel/template</code> 这五个包的 api 的使用。</p>
<h2 data-id="heading-1">@babel/parser</h2>
<p>babel parser 叫 babylon，是基于 acorn 实现的，扩展了很多语法，可以支持 es next（现在支持到 es2020）、jsx、flow、typescript 等语法的解析，其中 jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。</p>
<p>它提供了有两个 api：parse 和 parseExpression。两者都是把源码转成 AST，不过 parse 返回的 AST 根节点是 File（整个 AST），parseExpression 返回的 AST 根节点是是 Expression（表达式的 AST），粒度不同。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span>, options?: ParserOptions</span>): <span class="hljs-title">File</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExpression</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span>, options?: ParserOptions</span>): <span class="hljs-title">Expression</span>
</span></span></code></pre>
<p>详细的 options 可以查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-parser%23options" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-parser#options" ref="nofollow noopener noreferrer">文档</a>。其实主要分为两类，一是 parse 的内容是什么，二是以什么方式去 parse</p>
<p><strong>parse 的内容是什么：</strong></p>
<ul>
<li><code>plugins</code>： 指定jsx、typescript、flow 等插件来解析对应的语法</li>
<li><code>allowXxx</code>： 指定一些语法是否允许，比如函数外的 await、没声明的 export等</li>
<li><code>sourceType</code>： 指定是否支持解析模块语法，有 module、script、unambiguous 3个取值，module 是解析 es module 语法，script 则不解析 es module 语法，当作脚本执行，unambiguous 则是根据内容是否有 import 和 export 来确定是否解析 es module 语法。</li>
</ul>
<p><strong>以什么方式 parse</strong></p>
<ul>
<li><code>strictMode</code> 是否是严格模式</li>
<li><code>startLine</code> 从源码哪一行开始 parse</li>
<li><code>errorRecovery</code> 出错时是否记录错误并继续往下 parse</li>
<li><code>tokens</code> parse 的时候是否保留 token 信息</li>
<li><code>ranges</code> 是否在 ast 节点中添加 ranges 属性</li>
</ul>
<p>其实最常用的 option 就是 plugins、sourceType 这两个，比如要 parse tsx 模块，那么就可以这样来写</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/parser"</span>).parse(<span class="hljs-string">"code"</span>, {
  <span class="hljs-attr">sourceType</span>: <span class="hljs-string">"module"</span>,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-string">"jsx"</span>,
    <span class="hljs-string">"typescript"</span>
  ]
});
</code></pre>
<h2 data-id="heading-2">@babel/traverse</h2>
<p>parse 出的 AST 由 <code>@babel/traverse</code> 来遍历和修改，babel traverse 包提供了 traverse 方法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">parent, opts</span>)
</span></code></pre>
<p>常用的就前面两个参数，parent 指定要遍历的 AST 节点，opts 指定 visitor 函数。babel 会在遍历 parent 对应的 AST 时调用相应的 visitor 函数。</p>
<h4 data-id="heading-3">遍历过程</h4>
<p>visitor 对象的 value 是对象或者函数：</p>
<ul>
<li>如果 value 为函数，那么就相当于是 enter 时调用的函数。</li>
<li>如果 value 为对象，则可以明确指定 enter 或者 exit 时的处理函数。</li>
</ul>
<p>函数会接收两个参数 path 和 state。</p>
<pre><code class="hljs language-javascript" lang="javascript">visitor: {
    Identifier (path, state) {},
    <span class="hljs-attr">StringLiteral</span>: {
        enter (path, state) {},
        exit (path, state) {}
    }
}
</code></pre>
<p>enter 时调用是在遍历当前节点的子节点前调用，exit 时调用是遍历完当前节点的子节点后调用。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5768a7c151914586ab2a5b09b698b4d7~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>可以为单个节点的类型，也可以是多个节点类型通过 <code>|</code> 连接，还可以通过别名指定一系列节点类型。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 进入 FunctionDeclaration 节点时调用</span>
traverse(ast, {
  <span class="hljs-attr">FunctionDeclaration</span>: {
      <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path, state</span>)</span> {}
  }
})

<span class="hljs-comment">// 默认是进入节点时调用，和上面等价</span>
traverse(ast, {
  <span class="hljs-function"><span class="hljs-title">FunctionDeclaration</span>(<span class="hljs-params">path, state</span>)</span> {}
})

<span class="hljs-comment">// 进入 FunctionDeclaration 和 VariableDeclaration 节点时调用</span>
traverse(ast, {
  <span class="hljs-string">'FunctionDeclaration|VariableDeclaration'</span>(path, state) {}
})

<span class="hljs-comment">// 通过别名指定离开各种 Declaration 节点时调用</span>
traverse(ast, {
  <span class="hljs-attr">Declaration</span>: {
      <span class="hljs-function"><span class="hljs-title">exit</span>(<span class="hljs-params">path, state</span>)</span> {}
  }
})

</code></pre>
<p>具体的别名有哪些在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-types%2Fsrc%2Fast-types%2Fgenerated%2Findex.ts%23L2489-L2535" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2489-L2535" ref="nofollow noopener noreferrer">babel-types 的类型定义</a>可以查。</p>
<h4 data-id="heading-4">path</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538aefbdff92426c98c7f1da1feeb246~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>path 是遍历过程中的路径，会保留上下文信息，有很多属性和方法，比如:</p>
<ul>
<li>path.node 指向当前 AST 节点</li>
<li>path.get、path.set 获取和设置当前节点属性的 path</li>
<li>path.parent 指向父级 AST 节点</li>
<li>path.getSibling、path.getNextSibling、path.getPrevSibling 获取兄弟节点</li>
<li>path.find 从当前节点向上查找节点</li>
</ul>
<p>这些属性和方法是获取当前节点以及它的关联节点的</p>
<ul>
<li>path.scope 获取当前节点的作用域信息</li>
</ul>
<p>这个属性可以获取作用域的信息</p>
<ul>
<li>path.isXxx 判断当前节点是不是 xx 类型</li>
<li>path.assertXxx 判断当前节点是不是 xx 类型，不是则抛出异常</li>
</ul>
<p>isXxx、assertXxx 系列方法可以用于判断 AST 类型</p>
<ul>
<li>path.insertBefore、path.insertAfter 插入节点</li>
<li>path.replaceWith、path.replaceWithMultiple、replaceWithSourceString 替换节点</li>
<li>path.remove 删除节点</li>
</ul>
<p>这些方法可以对 AST 进行增删改</p>
<ul>
<li>path.skip 跳过当前节点的子节点的遍历</li>
<li>path.stop 结束后续遍历</li>
</ul>
<p>这俩方法可以跳过一些遍历</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ed2f4589d341de9b407ef7e58e58a0~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<p>上面罗列了几个常用的 api，可以通过这些 api 完成对 AST 的操作。当然，path 的 api 不是只有这些，后面实战案例用到了再介绍。</p>
<h4 data-id="heading-5">state</h4>
<p>第二个参数 state 则是遍历过程中在不同节点之间传递数据的机制，插件会通过 state 传递 options 和 file 信息，我们也可以通过 state 存储一些遍历过程中的共享数据。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee26748e8dd54dcca660e593271411be~tplv-k3u1fbpfcp-watermark.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
<h2 data-id="heading-6">@babel/types</h2>
<p>遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型，这时候就需要 <code>@babel/types</code> 包。</p>
<p>举例来说，如果要创建IfStatement就可以调用</p>
<pre><code class="hljs language-javascript" lang="javascript">t.ifStatement(test, consequent, alternate);
</code></pre>
<p>而判断节点是否是 IfStatement 就可以调用 isIfStatement 或者 assertIfStatement</p>
<pre><code class="hljs language-javascript" lang="javascript">t.isIfStatement(node, opts);
t.assertIfStatement(node, opts);
</code></pre>
<p>opts 可以指定一些属性是什么值，增加更多限制条件，做更精确的判断。</p>
<pre><code class="hljs language-javascript" lang="javascript">t.isIdentifier(node, { <span class="hljs-attr">name</span>: <span class="hljs-string">"paths"</span> })
</code></pre>
<p>isXxx 会返回 boolean 表示结果，而 assertXxx 则会在类型不一致时抛异常。</p>
<p>所有的 AST 的 build、assert 的 api 可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-types%23api" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-types#api" ref="nofollow noopener noreferrer">babel types 文档</a>中查。</p>
<h2 data-id="heading-7">@babel/template</h2>
<p>通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 <code>@babel/template</code> 包来批量创建。</p>
<p>这个包有这些 api：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> ast = template(code, [opts])(args);
<span class="hljs-keyword">const</span> ast = template.ast(code, [opts]);
<span class="hljs-keyword">const</span> ast = template.program(code, [opts]);
</code></pre>
<p>如果是根据模版创建整个 AST，那么用 template.ast 或者 template.program 方法，这俩都是直接返回 ast 的，template.program 返回的 AST 的根节点是 Program。</p>
<p>如果知道具体创建的 AST 的类型，可以使用 template.expression、template.statement、template.statements 等方法创建具体的 AST。</p>
<p>默认 template.ast 创建的 Expression 会被包裹一层 ExpressionStatement 节点（会被当成表达式语句来 parse），但当 template.expression 方法创建的 AST 就不会。</p>
<p>如果模版中有占位符，那么就用 template 的 api，在模版中写一些占位的参数，调用时传入这些占位符参数对应的 AST 节点。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fn = template(<span class="hljs-string">`console.log(NAME)`</span>);

<span class="hljs-keyword">const</span> ast = fn({
  <span class="hljs-attr">NAME</span>: t.stringLiteral(<span class="hljs-string">"guang"</span>),
});
</code></pre>
<p>或者</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fn = template(<span class="hljs-string">`console.log(%%NAME%%)`</span>);

<span class="hljs-keyword">const</span> ast = fn({
  <span class="hljs-attr">NAME</span>: t.stringLiteral(<span class="hljs-string">"guang"</span>),
});
</code></pre>
<p>这两种占位符的写法都可以，当占位符和其他变量名冲突时可以用第二种。</p>
<h2 data-id="heading-8">@babel/generator</h2>
<p>AST 转换完之后就要打印成目标代码字符串，通过 <code>@babel/generator</code> 包的 generate api</p>
<pre><code class="">function (ast: Object, opts: Object, code: string): {code, map} 
</code></pre>
<p>第一个参数是要打印的 AST</p>
<p>第二个参数是 options，指定打印的一些细节，比如通过 comments 指定是否包含注释，通过 minified 指定是否包含空白字符</p>
<p>第三个参数当<a ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=undefined">多个文件合并打印</a>的时候需要用到</p>
<p>options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { code, map } = generate(ast, { <span class="hljs-attr">sourceMaps</span>: <span class="hljs-literal">true</span> })
</code></pre>
<h2 data-id="heading-9">@babel/code-frame</h2>
<p>当有错误信息要打印的时候，需要打印错误位置的代码，可以使用<code>@babel/code-frame</code>。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> result = codeFrameColumns(rawLines, location, {
  <span class="hljs-comment">/* options */</span>
});
</code></pre>
<p>options 可以设置 highlighted （是否高亮）、message（展示啥错误信息）。</p>
<p>比如</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { codeFrameColumns } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/code-frame"</span>);

<span class="hljs-keyword">try</span> {
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"xxx 错误"</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.error(codeFrameColumns(<span class="hljs-string">`const name = guang`</span>, {
      <span class="hljs-attr">start</span>: { <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">column</span>: <span class="hljs-number">14</span> }
  }, {
    <span class="hljs-attr">highlightCode</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">message</span>: err.message
  }));
}
</code></pre>
<p>会有比较友好的打印信息</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31ce65fd2f644439f2848b0e0e94c1b~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
<h2 data-id="heading-10">@babel/core</h2>
<p>前面的包是完成某一部分的功能的，而 <code>@babel/core</code> 包则是基于它们完成整个编译流程，从源码到目标代码，生成 sourcemap。</p>
<pre><code class="hljs language-javascript" lang="javascript">transformSync(code, options); <span class="hljs-comment">// =&gt; { code, map, ast }</span>
transformFileSync(filename, options); <span class="hljs-comment">// =&gt; { code, map, ast }</span>
transformFromAstSync(
  parsedAst,
  sourceCode,
  options
); <span class="hljs-comment">// =&gt; { code, map, ast }</span>
</code></pre>
<p>前三个 transformXxx 的 api 分别是从源代码、源代码文件、源代码 AST 开始处理，最终生成目标代码和 sourcemap。</p>
<p>options 主要配置 plugins 和 presets，指定具体要做什么转换。</p>
<p>这些 api 也同样提供了异步的版本，异步地进行编译，返回一个 promise</p>
<pre><code class="hljs language-javascript" lang="javascript">transformAsync(<span class="hljs-string">"code();"</span>, options).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {})
transformFileAsync(<span class="hljs-string">"filename.js"</span>, options).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {})
transformFromAstAsync(parsedAst, sourceCode, options).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {})
</code></pre>
<p>注意：transformXxx 的 api，已经被标记为过时了，后续会删掉，不建议用，直接用 transformXxxSync 和 transformXxxAsync。</p>
<p>@babel/core 包还有一个 createConfigItem 的 api，用于 plugin 和 preset 的封装，后面章节会涉及到。</p>
<pre><code class="hljs language-javascript" lang="javascript">createConfigItem(value, options) <span class="hljs-comment">// configItem</span>
</code></pre>
<h2 data-id="heading-11">总结</h2>
<p>这一节我们了解了编译过程中各阶段的 api：</p>
<ul>
<li><code>@babel/parser</code> 对源码进行 parse，可以通过 plugins、sourceType 等来指定 parse 语法</li>
<li><code>@babel/traverse</code> 通过 visitor 函数对遍历到的 ast 进行处理，分为 enter 和 exit 两个阶段，具体操作 AST 使用 path 的 api，还可以通过 state 来在遍历过程中传递一些数据</li>
<li><code>@babel/types</code> 用于创建、判断 AST 节点，提供了 xxx、isXxx、assertXxx 的 api</li>
<li><code>@babel/template</code> 用于批量创建节点</li>
<li><code>@babel/code-frame</code> 可以创建友好的报错信息</li>
<li><code>@babel/generator</code> 打印 AST 成目标代码字符串，支持 comments、minified、sourceMaps 等选项。</li>
<li><code>@babel/core</code> 基于上面的包来完成 babel 的编译流程，可以从源码字符串、源码文件、AST 开始。</li>
</ul>
<p>学完这一节，我们可以用 babel 的 api 来实现一些功能了，下一节开始第一个实战案例。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>